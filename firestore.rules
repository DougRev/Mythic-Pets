/**
 * @description This ruleset enforces a strict user-ownership model for all data. Users can only access their own profiles, pets, personas, and stories. It also defines security for file storage.
 * @dataStructure
 *   /users/{userId} - User profile data.
 *   /pets/{petId} - Pet profiles owned by a user.
 *   /users/{userId}/petProfiles/{petProfileId} - Pet profiles owned by the user.
 *   /users/{userId}/petProfiles/{petProfileId}/aiPersonas/{aiPersonaId} - AI personas for each pet profile.
 *   /users/{userId}/petProfiles/{petProfileId}/aiPersonas/{aiPersonaId}/aiStories/{aiStoryId} - AI stories for each AI persona.
 *   /users/{userId}/petProfiles/{petProfileId}/aiPersonas/{aiPersonaId}/aiStories/{aiStoryId}/chapters/{chapterId} - Chapters for each story.
 *   /publishedStories/{publishedStoryId} - Publicly shared stories for the gallery.
 * @keySecurityDecisions
 *   - Users can only create, read, update, and delete their own data.
 *   - The public gallery (`publishedStories`) is read-only for all users, but write access is restricted to the original author.
 *   - Listing operations are restricted to the owner of the data for private collections.
 * @denormalizationForAuthorization
 *   - User ownership is enforced by nesting all data under the /users/{userId} path, eliminating the need for get() calls to verify ownership.
 *   - The `authorId` field in `publishedStories` is used to verify ownership for write/delete operations on public content.
 */
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces access control for user profiles. Only the owner can read, update, or delete their profile.
     * @path /users/{userId}
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted

      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if isExistingOwner(userId) && isUpdatingAllowedFields(request.resource.data);
      allow delete: if isExistingOwner(userId);

        /**
         * @description Enforces access control for pet profiles. Only the owner of the user profile can access the pet profiles.
         * @path /users/{userId}/petProfiles/{petProfileId}
         */
        match /petProfiles/{petProfileId} {
          allow get, list: if isOwner(userId);

          allow create: if isOwner(userId) && request.resource.data.userProfileId == userId;
          allow update: if isExistingOwner(userId) && request.resource.data.userProfileId == userId;
          allow delete: if isExistingOwner(userId);

            /**
             * @description Enforces access control for AI personas. Only the owner of the user profile can access the AI personas.
             * @path /users/{userId}/petProfiles/{petProfileId}/aiPersonas/{aiPersonaId}
             */
            match /aiPersonas/{aiPersonaId} {
              allow get, list: if isOwner(userId);

              allow create: if isOwner(userId);
              allow update: if isExistingOwner(userId);
              allow delete: if isExistingOwner(userId);

                /**
                 * @description Enforces access control for AI stories. Only the owner of the user profile can access the AI stories.
                 * @path /users/{userId}/petProfiles/{petProfileId}/aiPersonas/{aiPersonaId}/aiStories/{aiStoryId}
                 */
                match /aiStories/{aiStoryId} {
                  allow get, list: if isOwner(userId);

                  allow create: if isOwner(userId);
                  allow update: if isOwner(userId);
                  allow delete: if isExistingOwner(userId);

                  match /chapters/{chapterId} {
                    allow get, list: if isOwner(userId);
                    allow create, update, delete: if isOwner(userId);
                  }
                }
            }
        }
    }
    
    /**
     * @description Enforces access control for the public story gallery.
     * @path /publishedStories/{publishedStoryId}
     */
    match /publishedStories/{publishedStoryId} {
        // Anyone can read stories in the gallery
        allow get, list: if true;

        // Only the authenticated author can publish a story
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        
        // Allow any signed-in user to update the document (for liking).
        allow update: if isSignedIn();

        // Only the author can delete their published story
        allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid;

        // Chapter rules for public stories
        match /chapters/{chapterId} {
            // Anyone can read chapters of a published story
            allow get, list: if true;
            // Allow creation of chapters only by signed-in users (implicitly protected by parent create rule)
            allow create: if isSignedIn();
            // Allow deletion only by the story's author.
            allow delete: if get(/databases/$(database)/documents/publishedStories/$(publishedStoryId)).data.authorId == request.auth.uid;
            // Nobody can update the public copy of chapters after creation
            allow update: if false;
        }
    }

    /**
     * @description Enforces access control for public personas.
     * @path /publicPersonas/{personaId}
     */
    match /publicPersonas/{personaId} {
        // Anyone can read public personas
        allow get, list: if true;
        // Only the original author (owner) of the persona can create/update it.
        // We'd need to store the author's UID in the public persona document.
        allow create, update: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        // Public personas can't be deleted directly, they are removed when the original is deleted.
        allow delete: if false;
    }
  }

  // Helper functions
  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
  
  function isUpdatingAllowedFields(data) {
    let allowedFields = ['displayName', 'photoURL', 'generationCredits', 'planType', 'stripeCustomerId', 'subscriptionStatus', 'subscriptionPeriodEnd'];
    let receivedKeys = data.keys();
    
    // Check that every key in the request is in the allowed list
    return receivedKeys.hasOnly(allowedFields);
  }
}
